# fastlane_require 'dotenv'
# fastlane_require 'spaceship'
# fastlane_require 'time'

# Uncomment the line if you want fastlane to automatically update itself
# update_fastlane

before_all do |lane, options|
  # git_pull
  # ENV['MAILGUN_SANDBOX_POSTMASTER'] = 'issenn@sandboxc3b6b7d6022b484eabc7c39f728536a5.mailgun.org'
  # ENV['MAILGUN_APIKEY'] = '5d21a2e0cce1996b200d8f991d72856d-a4502f89-ce938adb'
  # ENV['FIR_APP_TOKEN'] = '9611b6a99d280463039cbb64b7eb24ca'
  ENV["GIT_BRANCH"] = git_branch
  ENV['VERSIONNAME'] ||= get_version_number
#   ENV['VERSIONCODE'] ||= get_info_plist_value(key: "CFBundleVersion")
  ENV['VERSIONCODE'] ||= increment_build_number

  # puts get_build_number
  ENV['CHANGELOG'] = read_changelog(
    changelog_path: './CHANGELOG.md', # Specify path to CHANGELOG.md
    section_identifier: '[Unreleased]', # Specify what section to read
    excluded_markdown_elements: ['-', '###']  # Specify which markdown elements should be excluded
  )
  
#   ENV['CHANGELOG'] = make_changelog_from_jenkins(
#   # Optional, lets you set a changelog in the case is not generated on Jenkins or if ran outside of Jenkins
#     fallback_changelog: "Bug fixes and performance enhancements",
#     include_commit_body: true
#   )
  
#   changelog_from_git_commits(
#       between: ["56d8b3511", "56d8b3511"],
#       merge_commit_filtering: "exclude_merges" 
#     )
  
#   changelog = Actions.lane_context[:FL_CHANGELOG]
#   puts "---#{changelog}---"
  
#   ENV['CHANGELOG'] = changelog_from_git_commits(
#       between: ["56d8b3511", "56d8b3511"],
#       merge_commit_filtering: "exclude_merges" 
#     )
  
#     puts "2---#{ENV['CHANGELOG']}---"


  ENV['IOS_GROUP'] = 'https://qyapi.weixin.qq.com/cgi-bin/webhook/send?key=ff00389c-ece4-4648-9a7e-0f5f50c06a23'
  ENV['PROJECT_GROUP'] = 'https://qyapi.weixin.qq.com/cgi-bin/webhook/send?key=702e4d43-270b-4c1d-9d9c-eadc5ac3651a'

  wechatwork(
    webhook: ENV['IOS_GROUP'],
    markdown: "**#{ENV['VERSIONNAME']} (#{ENV['VERSIONCODE']}) BUILD START** \r\n\n  #{ENV['CHANGELOG']}",
    mentioned_mobile_list: []
  )
end

before_each do |lane, options|
  # ...
end

lane :do_appfile_init do |options|
  prepare_lane_options(
    options: options,
    bind_params: [
      Actions::BindParamBuilder.new(:xcodeproj).env_var("XCODEPROJ").build(),
      Actions::BindParamBuilder.new(:fetch_app_identifier).default_value(true).build(),
      Actions::BindParamBuilder.new(:fetch_apple_id).default_value(true).build(),
      Actions::BindParamBuilder.new(:fetch_team_name).default_value(true).build(),
      Actions::BindParamBuilder.new(:fetch_itc_team_name).default_value(true).build()
    ]
  )
  bind_params = []
  app_identifier = nil
  if options[:fetch_app_identifier] == true
    app_identifier = CredentialsManager::AppfileConfig.try_fetch_value(:app_identifier)
    bind_params.push(Actions::BindParamBuilder.new("App identifier").lane_context(:APPFILE_APP_IDENTIFIER).default_value(app_identifier).required().build())
  end
  if options[:fetch_apple_id] == true
    bind_params.push(Actions::BindParamBuilder.new("Apple ID").lane_context(:APPFILE_APPLE_ID).default_value(CredentialsManager::AppfileConfig.try_fetch_value(:apple_id)).build())
  end
  if options[:fetch_team_name] == true
    bind_params.push(Actions::BindParamBuilder.new("Team name").lane_context(:APPFILE_TEAM_NAME).default_value(CredentialsManager::AppfileConfig.try_fetch_value(:team_name)).build())
  end
  if options[:fetch_itc_team_name] == true
    bind_params.push(Actions::BindParamBuilder.new("iTunes Connect Team name").lane_context(:APPFILE_ITC_TEAM_NAME).default_value(CredentialsManager::AppfileConfig.try_fetch_value(:itc_team_name)).build())
  end
  user_validation(bind_params: bind_params)
  if app_identifier != Actions.lane_context[:APPFILE_APP_IDENTIFIER]
    project_info = get_project_info(xcodeproj: options[:xcodeproj])
    update_app_identifier(
      app_identifier: Actions.lane_context[:APPFILE_APP_IDENTIFIER],
      xcodeproj: project_info[:xcodeproj],
      plist_path: project_info[:info_plist]
    )
  end
  app_file_data = ""
  if app_identifier = Actions.lane_context[:APPFILE_APP_IDENTIFIER]
    app_file_data += "app_identifier \"#{app_identifier}\" # The bundle identifier of your app\n"
  end
  if apple_id = Actions.lane_context[:APPFILE_APPLE_ID]
    app_file_data += "apple_id \"#{apple_id}\" # Your Apple email address\n"
  end
  if team_name = Actions.lane_context[:APPFILE_TEAM_NAME]
    app_file_data += "team_name \"#{team_name}\"\n"
  end
  if itc_team_name = Actions.lane_context[:APPFILE_ITC_TEAM_NAME]
    app_file_data += "itc_team_name \"#{itc_team_name}\"\n"
  end
  File.open("Appfile", "w") { |file|
    file.puts(app_file_data)
  }
end

lane :do_update_cocoapods do |lane, options|
  if files_matching(pattern: "Podfile") != nil
    
    wechatwork(
      webhook: ENV['IOS_GROUP'],
      markdown: "**POD INSTALLING**",
      mentioned_mobile_list: []
    )
   
    cocoapods(
      repo_update: true,
      silent: false,
      verbose: true,
      use_bundle_exec: true,
      podfile: './Podfile',
      try_repo_update_on_error: true,
      error_callback: lambda { |result|
        cocoapods(
          repo_update: true,
          silent: false,
          verbose: true,
          use_bundle_exec: true,
          podfile: './Podfile',
          error_callback: lambda { |result|	
            wechatwork(
              webhook: ENV['IOS_GROUP'],
              markdown: "❌**POD INSTALL FAILED**",
              mentioned_mobile_list: []
            )
          }
        )
      }
    )

    wechatwork(
      webhook: ENV['IOS_GROUP'],
      markdown: "✅**POD INSTALL SUCCEED",
      mentioned_mobile_list: []
    )

  end
end

lane :do_run_tests do |options|
  prepare_lane_options(
    options: options,
    bind_params: [
      Actions::BindParamBuilder.new(:test_scheme).env_var("TEST_SCHEME").ci_required().build(),
      Actions::BindParamBuilder.new(:xcworkspace).env_var("XCWORKSPACE").build(),
      Actions::BindParamBuilder.new(:xcodeproj).env_var("XCODEPROJ").build()
    ]
  )
  do_update_cocoapods
  scan(
    workspace: options[:xcworkspace],
    project: options[:xcodeproj],
    scheme: options[:test_scheme],
    clean: true
  )
end

desc "Submit a new Release Build to all"
lane :do_publish_all do |lane, options|
  do_publish
end

lane :do_publish do |lane, options|
  do_update_cocoapods
  
  wechatwork(
    webhook: ENV['IOS_GROUP'],
    markdown: "**MATCHING**",
    mentioned_mobile_list: []
  )

  match

  wechatwork(
    webhook: ENV['IOS_GROUP'],
    markdown: "✅**MATCH SUCCEED**",
    mentioned_mobile_list: []
  )

  wechatwork(
    webhook: ENV['IOS_GROUP'],
    markdown: "**BUILDING**",
    mentioned_mobile_list: []
  )

  ENV['DELIVER_IPA_PATH']=gym(
    export_options: {
      compileBitcode: true,
      stripSwiftSymbols: true,
      uploadBitcode: false,
      uploadSymbols: false,
      thinning: "<none>",
      iCloudContainerEnvironment: "Production"
    }
  )

  wechatwork(
    webhook: ENV['IOS_GROUP'],
    markdown: "✅**BUILD SUCCEED**",
    mentioned_mobile_list: []
  )

  wechatwork(
    webhook: ENV['IOS_GROUP'],
    markdown: "**SYMBOLS UPLOADING**",
    mentioned_mobile_list: []
  )
  upload_symbols_to_crashlytics()
  wechatwork(
    webhook: ENV['IOS_GROUP'],
    markdown: "✅**SYMBOLS UPLOADED",
    mentioned_mobile_list: []
  )

  do_upload_firim
end

lane :do_upload_firim do |lane, options|
  begin
    change_log = "[#{ENV['GIT_BRANCH']}]\r\n---\r\n" + ENV['CHANGELOG']
    
    wechatwork(
      webhook: ENV['IOS_GROUP'],
      markdown: "**UPLOADING TO FIR**",
      mentioned_mobile_list: []
    )
    
    firim(
      app_version: ENV['VERSIONNAME'],
      app_build_version: ENV['VERSIONCODE'],
      app_changelog: change_log
    )
    # send_e_mail(
    #   stmp_server: "smtp.exmail.qq.com",
    #   user_name: "update@hellotalk.com",
    #   password: "Hello123",
    #   subject: "default",
    #   message_body: "Hi! @issenn \r\n A new app upload success \r\n#{ENV['CHANGELOG']}"
    # )

    wechatwork(
      webhook: ENV['IOS_GROUP'],
      markdown: "✅**UPLOAD TO FIR SUCCEED**",
      mentioned_mobile_list: []
    )
    
    wechatwork(
      webhook: ENV['PROJECT_GROUP'],
      markdown: "**HelloTalk(iOS) #{ENV['VERSIONNAME']} (#{ENV['VERSIONCODE']})** \r\n\n  #{ENV['CHANGELOG']}",
      mentioned_mobile_list: ["18779144521", "18126009603"]
    )
    
    commit_version_bump(
       message: "#{ENV['VERSIONNAME']} (#{ENV['VERSIONCODE']})"
    )
    
    push_to_git_remote
    
    wechatwork(
      webhook: ENV['IOS_GROUP'],
      markdown: "✅**increment build number and pushed**",
      mentioned_mobile_list: []
    )
    
    $upload_retry=0
  rescue => ex
    $upload_retry += 1
    if $upload_retry < 3
      do_upload_firim
    else
      # raise ex
      wechatwork(
        webhook: ENV['IOS_GROUP'],
        markdown: "❌**UPLOAD TO FIR FAILED",
        mentioned_mobile_list: []
      )
      puts ex
    end
  end
end

lane :do_lookup_cert_id do |lane, options|
  require 'spaceship'
  Spaceship.login('issenn@hellotalk.com')
  Spaceship.select_team
  Spaceship.certificate.all.each do |cert|
    cert_type = Spaceship::Portal::Certificate::CERTIFICATE_TYPE_IDS[cert.type_display_id].to_s.split("::")[-1]
    puts "Cert id: #{cert.id}, name: #{cert.name}, expires: #{cert.expires.strftime("%Y-%m-%d")}, type: #{cert_type}"
  end
end

after_each do |lane, options|
  # ...
end

after_all do |lane, options|
   wechatwork(
    webhook: ENV['IOS_GROUP'],
    markdown: "**BUILD END**",
    mentioned_mobile_list: []
  )
end

error do |lane, exception, options|
  if options[:debug]
    puts "Hi :)"
  end
  UI.message(exception.message)
end
